{"name":"pipeR","tagline":"Pipe operator and function based on intuitive syntax","body":"\r\n\r\n# pipeR\r\n\r\n[![Build Status](https://travis-ci.org/renkun-ken/pipeR.png?branch=master)](https://travis-ci.org/renkun-ken/pipeR)\r\n\r\nPipe operator and function based on intuitive syntax\r\n\r\n## What's new in 0.4?\r\n\r\n[Release notes](https://github.com/renkun-ken/pipeR/releases)\r\n\r\n#### 0.4-2\r\n\r\n- **API Change**: \r\n    * lambda expression like `(x -> expr)` is deprecated, use `(x ~ expr)` instead.\r\n    * `fun()` in `Pipe` object is deprecated, use `.()` instead.\r\n- Add side-effect piping: `x %>>% (~ expr)` or `x %>>% (~ i ~ expr)`. `expr` will only be evaluated for its side effect and return `x`.\r\n- Add question piping: `x %>>% (? expr)` where `expr` is an expression or a lambda expression. `expr` will only be printed and return `x`.\r\n- Pipe object now supports subsetting, extracting, and assigning, and preserves Pipe object.\r\n\r\n#### 0.4-1\r\n\r\n- Add element extraction with `x %>>% (name)`.\r\n\r\n#### 0.4\r\n\r\n- **Major API Change**: `%>>%` operator now handles all pipeline mechanisms and other operators are deprecated.\r\n- Add `Pipe()` function that supports object-based pipeline operation.\r\n\r\n## Installation\r\n\r\nInstall from CRAN:\r\n\r\n```r\r\ninstall.packages(\"pipeR\")\r\n```\r\n\r\nInstall the development version from GitHub (`devtools` package is required):\r\n\r\n```r\r\ndevtools::install_github(\"pipeR\",\"renkun-ken\")\r\n```\r\n\r\n## Usage\r\n\r\n### `%>>%`\r\n\r\n`%>>%` operator behaves based on a set of syntax:\r\n\r\n* Pipe to first argument and `.` in a function if followed by a function name or call\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot\r\n```\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot(col=\"red\")\r\n```\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot(col=\"red\", main=length(.))\r\n```\r\n\r\n* Pipe to `.` in an expression if it is enclosed within `{}` or `()`\r\n\r\n```r\r\nmtcars %>>%\r\n  { lm(mpg ~ cyl + wt, data = .) }\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  ( lm(mpg ~ cyl + wt, data = .) )\r\n```\r\n\r\n* Pipe by lambda expression if followed by `(x ~ expr)`\r\n\r\n```r\r\nmtcars %>>%\r\n  (df ~ lm(mpg ~ cyl + wt, data = df))\r\n```\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  (x ~ plot(x, col=\"red\", main=length(x)))\r\n```\r\n\r\n* Pipe for side effect if lambda expression starts by `~`\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  (~ cat(\"number:\",length(.),\"\\n\")) %>>%\r\n  summary()\r\n```\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  (~ x ~ cat(\"number:\",length(x),\"\\n\")) %>>%\r\n  summary()\r\n```\r\n\r\n* Ask question if lambda expression starts by `?`\r\n\r\n```r\r\niris %>>% \r\n  (? ncol(.)) %>>%\r\n  summary()\r\n```\r\n\r\n```r\r\niris %>>% \r\n  (? df ~ ncol(df)) %>>%\r\n  summary()\r\n```\r\n\r\n* Extract element if followed by name in `()`\r\n\r\n```r\r\nmtcars %>>%\r\n  (mpg)\r\n```\r\n\r\n* Working with [dplyr](https://github.com/hadley/dplyr/):\r\n\r\n```r\r\nlibrary(dplyr)\r\nmtcars %>>%\r\n  filter(mpg <= mean(mpg)) %>>%\r\n  (lm(mpg ~ wt + cyl, data = .)) %>>%\r\n  summary() %>>%\r\n  (coefficients)\r\n```\r\n\r\n* Working with [ggvis](http://ggvis.rstudio.com/):\r\n\r\n```r\r\nlibrary(ggvis)\r\nmtcars %>>%\r\n  ggvis(~mpg, ~wt) %>>%\r\n  layer_points()\r\n```\r\n\r\n* Working with [rlist](http://renkun.me/rlist/):\r\n\r\n```r\r\nlibrary(rlist)\r\n1:100 %>>%\r\n  list.group(. %% 3) %>>%\r\n  list.mapv(g ~ mean(g))\r\n```\r\n\r\n### `Pipe()`\r\n\r\n`Pipe()` creates a Pipe object that supports light-weight chaining without any external operator. Typically, start with `Pipe()` and end with `$value` or `[]` to extract the final value of the Pipe. \r\n\r\nAn internal function `.(...)` works in the same way with `x %>>% (...)` for dot piping, by lambda expression, for side effect, and element extraction.\r\n\r\n* Examples\r\n\r\n```r\r\nPipe(rnorm(1000))$\r\n  density(kernel = \"cosine\")$\r\n  plot(col = \"blue\")\r\n```\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(mpg)$\r\n  summary()\r\n```\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(~ cat(\"number of columns:\", ncol(.), \"\\n\"))$\r\n  lm(formula = mpg ~ wt + cyl)$\r\n  summary()$\r\n  .(coefficients)\r\n```\r\n\r\n* Subsetting and extracting\r\n\r\n```r\r\ndf <- Pipe(mtcars)\r\ndf[c(\"mpg\",\"wt\")]$lm(formula = mpg ~ wt)\r\ndf[[\"mpg\"]]$mean()\r\n```\r\n\r\n* Assigning values\r\n\r\n```r\r\ndf <- Pipe(list(a=1,b=2))\r\ndf$a <- 0\r\ndf$b <- NULL\r\n```\r\n\r\n* Working with dplyr:\r\n\r\n```r\r\nPipe(mtcars)$\r\n  filter(mpg >= mean(mpg))$\r\n  .(lm(mpg ~ wt + cyl, data = .))$\r\n  summary()$\r\n  .(coefficients)$\r\n  value\r\n```\r\n\r\n* Working with ggvis:\r\n\r\n```r\r\nPipe(mtcars)$\r\n  ggvis(~ mpg, ~ wt)$\r\n  layer_points()\r\n```\r\n\r\n* Working with rlist:\r\n\r\n```r\r\nPipe(1:100)$\r\n  list.group(. %% 3)$\r\n  list.mapv(g ~ mean(g))$\r\n  value\r\n```\r\n\r\n* For side effect:\r\n\r\n```r\r\nPipe(iris)$\r\n  .(~ cat(length(.), \"columns\",\"\\n\"))$\r\n  .(~ plot(.))$\r\n  summary()\r\n```\r\n\r\n## Vignettes\r\n\r\nThe package also provides the following vignettes:\r\n\r\n- [Introduction](http://cran.r-project.org/web/packages/pipeR/vignettes/Introduction.html)\r\n- [Examples](http://cran.r-project.org/web/packages/pipeR/vignettes/Examples.html)\r\n- [Performance](http://cran.r-project.org/web/packages/pipeR/vignettes/Performance.html)\r\n\r\n\r\n## Help overview\r\n\r\n```r\r\nhelp(package = pipeR)\r\n```\r\n\r\n## License\r\n\r\nThis package is under [MIT License](http://opensource.org/licenses/MIT).\r\n","google":"UA-47159422-1","note":"Don't delete this file! It's used internally to help with page regeneration."}