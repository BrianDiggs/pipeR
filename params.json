{"name":"pipeR","tagline":"Pipeline operators for R: Making command chaining flexible and straightforward","body":"# pipeR\r\n\r\n[![Build Status](https://travis-ci.org/renkun-ken/pipeR.png?branch=master)](https://travis-ci.org/renkun-ken/pipeR)\r\n\r\nPipeline operators for R: Making command chaining flexible and straightforward\r\n\r\n## What's New?\r\n\r\n**Major operator change** (See issue [#12](https://github.com/renkun-ken/pipeR/issues/12))\r\n\r\n[Release notes](https://github.com/renkun-ken/pipeR/releases)\r\n\r\n## Installation\r\n\r\nInstall from CRAN:\r\n\r\n```\r\ninstall.packages(\"pipeR\")\r\n```\r\n\r\nInstall the devel version from GitHub (`devtools` package is required):\r\n\r\n```\r\ndevtools::install_github(\"pipeR\",\"renkun-ken\")\r\n```\r\n\r\n## Motivation\r\n\r\nIn data-driven statistical computing and analysis, applying a chain of commands is a frequent situation. Consider the following example.\r\n\r\nSuppose we need to take these steps:\r\n\r\n1. Generate 10000 random numbers from normal distribution with mean 10 and standard deviation 1\r\n2. Take a sample of 100 without replacement from these numbers\r\n3. Take a log of the sample\r\n4. Take a difference of the log numbers\r\n5. Plot these log differences with red line segments.\r\n\r\nHere is the ordinary way we do this in R programming langauge:\r\n\r\n```\r\nplot(diff(log(sample(rnorm(10000,mean=10,sd=1),size=100,replace=FALSE))),col=\"red\",type=\"l\")\r\n```\r\n\r\nThe code is neither straightforward for reading nor flexible for modification. It is because the functions in the first few steps are hiding in the nested brackets, and the written order of the functions goes against the order of logic.\r\n\r\npipeR borrows the idea of F# pipeline operator which allows you to write the *object* first and *pipe* it to a following *function*. This package defines three binary pipe operators that provide different types of forward-piping mechanisms: first-argument piping (`%>>%`), free piping (`%:>%`), and lambda piping (`%|>%`). And the real magic of this kind of operators is chaining commands by the right order.\r\n\r\n### First-argument piping: `%>>%`\r\n\r\nThe first-argument pipe operator `%>>%` inserts the expression on the left-hand side to the first argument of the **function** on the right-hand side. In other words, `x %>>% f(a=1)` will be transformed to and be evaluated as `f(x,a=1)`. This operator accepts both function call, e.g. `plot()` or `plot(col=\"red\")`, and function name, e.g. `log` or `plot`.\r\n\r\n```\r\nrnorm(100) %>>% plot\r\n# plot(rnorm(100))\r\n\r\nrnorm(100) %>>% plot()\r\n# plot(rnorm(100))\r\n\r\nrnorm(100) %>>% plot(col=\"red\")\r\n# plot(rnorm(100),col=\"red\")\r\n\r\nrnorm(100) %>>% sample(size=100,replace=FALSE) %>>% hist\r\n# hist(sample(rnorm(100),size=100,replace=FALSE))\r\n```\r\n\r\nWith the first-argument pipe operator `%>>%`, you may rewrite the first example as\r\n\r\n```\r\nrnorm(10000,mean=10,sd=1) %>>%\r\n  sample(size=100,replace=FALSE) %>>%\r\n  log %>>%\r\n  diff %>>%\r\n  plot(col=\"red\",type=\"l\")\r\n```\r\n\r\n### Free piping: `%:>%`\r\n\r\nYou may not always want to pipe the object to the first argument of the next function. Then you can use free pipe operator `%:>%`, which takes `.` to represent the piped object on the left-hand side and evaluate the *expression* on the right-hand side with `.` as the piped object. In other words, you have the right to decide where the object should be piped to.\r\n\r\n```\r\nrnorm(100) %:>% plot(.)\r\n# plot(rnorm(100))\r\n\r\nrnorm(100) %:>% plot(., col=\"red\")\r\n# plot(rnorm(100),col=\"red\")\r\n\r\nrnorm(100) %:>% sample(., size=length(.)*0.5)\r\n# (`.` is piped to multiple places)\r\n\r\nmtcars %:>% lm(mpg ~ cyl + disp, data=.) %>>% summary\r\n# summary(lm(mgp ~ cyl + disp, data=mtcars))\r\n\r\nrnorm(100) %:>% \r\n  sample(.,length(.)*0.2,FALSE) %:>% \r\n  plot(.,main=sprintf(\"length: %d\",length(.)))\r\n# (`.` is piped to multiple places and mutiple levels)\r\n\r\nrnorm(100) %:>% {\r\n  par(mfrow=c(1,2))\r\n  hist(.,main=\"hist\")\r\n  plot(.,col=\"red\",main=sprintf(\"%d\",length(.)))\r\n}\r\n# (`.` is piped to an enclosed expression)\r\n\r\nrnorm(10000,mean=10,sd=1) %:>%\r\n  sample(.,size=length(.)/500,replace=FALSE) %>>%\r\n  log %>>%\r\n  diff %:>%\r\n  plot(.,col=\"red\",type=\"l\",main=sprintf(\"length: %d\",length(.)))\r\n# (`%>>%` and `%:>%` are used together. Be clear what they mean)\r\n```\r\n\r\n### Lambda piping: `%|>%`\r\n\r\nIt can be confusing to see multiple `.` symbols in the same context. In some cases, they may represent different things in the same expression. Even though the expression mostly still works, it may not be a good idea to keep it in that way. Here is an example:\r\n\r\n```\r\nmtcars %:>%\r\n  lm(mpg ~ ., data=.) %>>%\r\n  summary\r\n```\r\n\r\nThe code above works correctly with `%:>%` and `%>>%`, even though the two dots in the second line have different meanings. `.` in formula `mpg ~ .` represents all variables other than `mpg` in data frame `mtcars`; `.` in `data=.` represents `mtcars` itself. One way to reduce ambiguity is to use *lambda expression* that names the piped object on the left of `~` and specifies the expression to evaluate on the right.\r\n\r\nA new pipe operator `%|>%` is defined, which works with lambda expression in the formula form `x ~ f(x)`. More specifically, the expression will be interpreted as *`f(x)` is evaluated with `x` being the piped object*. Therefore, the previous example can be rewritten with `%|>%` like this:\r\n\r\n```\r\nmtcars %|>%\r\n  (df ~ lm(mpg ~ ., data=df)) %>>%\r\n  summary\r\n```\r\n\r\nMoreover, we could store the lambda expressions by assigning the formula to symbols.\r\n\r\n```\r\nrunlm <- df ~ lm(mpg ~ ., data=df)\r\nplotlm <- m ~ {\r\n  par(mfrow=c(2,2))\r\n  plot(m,ask=FALSE)\r\n}\r\n\r\nmtcars %|>%\r\n  runlm %|>%\r\n  plotlm\r\n``` \r\n\r\n### Mixed piping\r\n\r\nAll the pipe operators can be used together and each of them only works in their own way.\r\n\r\n```\r\nmtcars %|>%\r\n  (df ~ lm(mpg ~ ., data=df)) %>>%\r\n  summary %:>%\r\n  .$fstatistic\r\n```\r\n\r\n### Piping with `dplyr` package\r\n\r\n`dplyr` package provides a group of functions that make data transformation much easier. `%.%` is a built-in chain operator that pipes the previous result to the first-argument in the next function call. `%>>%` is fully compatible with `dplyr` and can replace `%.%` with more consistency.\r\n\r\nThe following code demonstrates mixed piping with `dplyr` functions.\r\n\r\n```\r\nlibrary(dplyr)\r\nlibrary(hflights)\r\nlibrary(pipeR)\r\ndata(hflights)\r\n\r\nhflights %>>%\r\n  mutate(Speed=Distance/ActualElapsedTime) %>>%\r\n  group_by(UniqueCarrier) %>>%\r\n  summarize(n=length(Speed),speed.mean=mean(Speed,na.rm = T),\r\n    speed.median=median(Speed,na.rm=T),\r\n    speed.sd=sd(Speed,na.rm=T)) %>>%\r\n  mutate(speed.ssd=speed.mean/speed.sd) %>>%\r\n  arrange(desc(speed.ssd)) %:>%\r\n  barplot(.$speed.ssd, names.arg = .$UniqueCarrier,\r\n    main=sprintf(\"Standardized mean of %d carriers\", nrow(.)))\r\n```\r\n\r\n## Notice\r\n\r\nThe reason why the three operators are not \"integrated\" into one is that I want to make the functionality of each operator as clear and independent as possible, so that guessing and ambiguity could be sharply reduced. When you decide to use pipe operators to build a chain of expressions, you need to know clearly how you want to pipe your results to the next level. The following bullets are a brief summary:\r\n\r\n1. `%>>%` only pipes an object to the first-argument of the next *function*, that is, `x %>>% f(...)` runs as `f(x,...)`.\r\n2. `%:>%` only evaluates the next *expression* with `.` representing the object being piped, that is, `x %:>% f(a,.,g(.))` runs as `f(a,x,g(x))`.\r\n3. `%|>%` only evaluates the *expression* on the right-hand side of `~` in the lambda expression formula with symbol on the left representing the object being piped, that is, `x %|>% (a ~ f(a,g(a)))` runs as `f(x,g(x))`.\r\n\r\n## Performance\r\n\r\nSince each pipe operators defined in this package specializes in its work and is made as simple as possible, the overhead is significantly lower than its peer implmentation in `magrittr` package. In general, `pipeR` is more than 3 times faster than `magrittr` and can be more than 30 times faster when the pipeline gets longer or when the data gets bigger. The detailed performance tests can be seen in issues.\r\n\r\n## Help overview\r\n\r\n```\r\nhelp(package = pipeR)\r\n```\r\n\r\n## License\r\n\r\nThis package is under [MIT License](http://opensource.org/licenses/MIT).\r\n","google":"UA-47159422-1","note":"Don't delete this file! It's used internally to help with page regeneration."}