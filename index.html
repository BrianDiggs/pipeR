<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="pipeR : Specialized, high-performance pipeline operators for R" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>pipeR</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/renkun-ken/pipeR">View on GitHub</a>

          <h1 id="project_title">pipeR</h1>
          <h2 id="project_tagline">Specialized, high-performance pipeline operators for R</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/renkun-ken/pipeR/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/renkun-ken/pipeR/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="piper" class="anchor" href="#piper"><span class="octicon octicon-link"></span></a>pipeR</h1>

<p><a href="https://travis-ci.org/renkun-ken/pipeR"><img src="https://travis-ci.org/renkun-ken/pipeR.png?branch=master" alt="Build Status"></a></p>

<p>Specialized, high-performance pipeline operators for R: Making command chaining fast, flexible and straightforward</p>

<h2>
<a name="whats-new" class="anchor" href="#whats-new"><span class="octicon octicon-link"></span></a>What's New?</h2>

<p><strong>Major operator change</strong> (See issue <a href="https://github.com/renkun-ken/pipeR/issues/12">#12</a>)</p>

<p><a href="https://github.com/renkun-ken/pipeR/releases">Release notes</a></p>

<h2>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Install from CRAN:</p>

<pre><code>install.packages("pipeR")
</code></pre>

<p>Install the devel version from GitHub (<code>devtools</code> package is required):</p>

<pre><code>devtools::install_github("pipeR","renkun-ken")
</code></pre>

<h2>
<a name="motivation" class="anchor" href="#motivation"><span class="octicon octicon-link"></span></a>Motivation</h2>

<p>In data-driven statistical computing and analysis, applying a chain of commands is a frequent situation. Consider the following example.</p>

<p>Suppose we need to take these steps:</p>

<ol>
<li>Generate 10000 random numbers from normal distribution with mean 10 and standard deviation 1</li>
<li>Take a sample of 100 without replacement from these numbers</li>
<li>Take a log of the sample</li>
<li>Take a difference of the log numbers</li>
<li>Plot these log differences with red line segments.</li>
</ol><p>Here is the ordinary way we do this in R programming langauge:</p>

<pre><code>plot(diff(log(sample(rnorm(10000,mean=10,sd=1),size=100,replace=FALSE))),col="red",type="l")
</code></pre>

<p>The code is neither straightforward for reading nor flexible for modification. It is because the functions in the first few steps are hiding in the nested brackets, and the written order of the functions goes against the order of logic.</p>

<p>pipeR borrows the idea of F# pipeline operator which allows you to write the <em>object</em> first and <em>pipe</em> it to a following <em>function</em>. This package defines three binary pipe operators that provide different types of forward-piping mechanisms: first-argument piping (<code>%&gt;&gt;%</code>), free piping (<code>%:&gt;%</code>), and lambda piping (<code>%|&gt;%</code>). And the real magic of this kind of operators is chaining commands by the right order.</p>

<h3>
<a name="first-argument-piping-" class="anchor" href="#first-argument-piping-"><span class="octicon octicon-link"></span></a>First-argument piping: <code>%&gt;&gt;%</code>
</h3>

<p>The first-argument pipe operator <code>%&gt;&gt;%</code> inserts the expression on the left-hand side to the first argument of the <strong>function</strong> on the right-hand side. In other words, <code>x %&gt;&gt;% f(a=1)</code> will be transformed to and be evaluated as <code>f(x,a=1)</code>. This operator accepts both function call, e.g. <code>plot()</code> or <code>plot(col="red")</code>, and function name, e.g. <code>log</code> or <code>plot</code>.</p>

<pre><code>rnorm(100) %&gt;&gt;% plot
# plot(rnorm(100))

rnorm(100) %&gt;&gt;% plot()
# plot(rnorm(100))

rnorm(100) %&gt;&gt;% plot(col="red")
# plot(rnorm(100),col="red")

rnorm(100) %&gt;&gt;% sample(size=100,replace=FALSE) %&gt;&gt;% hist
# hist(sample(rnorm(100),size=100,replace=FALSE))
</code></pre>

<p>With the first-argument pipe operator <code>%&gt;&gt;%</code>, you may rewrite the first example as</p>

<pre><code>rnorm(10000,mean=10,sd=1) %&gt;&gt;%
  sample(size=100,replace=FALSE) %&gt;&gt;%
  log %&gt;&gt;%
  diff %&gt;&gt;%
  plot(col="red",type="l")
</code></pre>

<h3>
<a name="free-piping-" class="anchor" href="#free-piping-"><span class="octicon octicon-link"></span></a>Free piping: <code>%:&gt;%</code>
</h3>

<p>You may not always want to pipe the object to the first argument of the next function. Then you can use free pipe operator <code>%:&gt;%</code>, which takes <code>.</code> to represent the piped object on the left-hand side and evaluate the <em>expression</em> on the right-hand side with <code>.</code> as the piped object. In other words, you have the right to decide where the object should be piped to.</p>

<pre><code>rnorm(100) %:&gt;% plot(.)
# plot(rnorm(100))

rnorm(100) %:&gt;% plot(., col="red")
# plot(rnorm(100),col="red")

rnorm(100) %:&gt;% sample(., size=length(.)*0.5)
# (`.` is piped to multiple places)

mtcars %:&gt;% lm(mpg ~ cyl + disp, data=.) %&gt;&gt;% summary
# summary(lm(mgp ~ cyl + disp, data=mtcars))

rnorm(100) %:&gt;% 
  sample(.,length(.)*0.2,FALSE) %:&gt;% 
  plot(.,main=sprintf("length: %d",length(.)))
# (`.` is piped to multiple places and mutiple levels)

rnorm(100) %:&gt;% {
  par(mfrow=c(1,2))
  hist(.,main="hist")
  plot(.,col="red",main=sprintf("%d",length(.)))
}
# (`.` is piped to an enclosed expression)

rnorm(10000,mean=10,sd=1) %:&gt;%
  sample(.,size=length(.)/500,replace=FALSE) %&gt;&gt;%
  log %&gt;&gt;%
  diff %:&gt;%
  plot(.,col="red",type="l",main=sprintf("length: %d",length(.)))
# (`%&gt;&gt;%` and `%:&gt;%` are used together. Be clear what they mean)
</code></pre>

<h3>
<a name="lambda-piping-" class="anchor" href="#lambda-piping-"><span class="octicon octicon-link"></span></a>Lambda piping: <code>%|&gt;%</code>
</h3>

<p>It can be confusing to see multiple <code>.</code> symbols in the same context. In some cases, they may represent different things in the same expression. Even though the expression mostly still works, it may not be a good idea to keep it in that way. Here is an example:</p>

<pre><code>mtcars %:&gt;%
  lm(mpg ~ ., data=.) %&gt;&gt;%
  summary
</code></pre>

<p>The code above works correctly with <code>%:&gt;%</code> and <code>%&gt;&gt;%</code>, even though the two dots in the second line have different meanings. <code>.</code> in formula <code>mpg ~ .</code> represents all variables other than <code>mpg</code> in data frame <code>mtcars</code>; <code>.</code> in <code>data=.</code> represents <code>mtcars</code> itself. One way to reduce ambiguity is to use <em>lambda expression</em> that names the piped object on the left of <code>~</code> and specifies the expression to evaluate on the right.</p>

<p>A new pipe operator <code>%|&gt;%</code> is defined, which works with lambda expression in the formula form <code>x ~ f(x)</code>. More specifically, the expression will be interpreted as <em><code>f(x)</code> is evaluated with <code>x</code> being the piped object</em>. Therefore, the previous example can be rewritten with <code>%|&gt;%</code> like this:</p>

<pre><code>mtcars %|&gt;%
  (df ~ lm(mpg ~ ., data=df)) %&gt;&gt;%
  summary
</code></pre>

<p>Moreover, we could store the lambda expressions by assigning the formula to symbols.</p>

<pre><code>runlm &lt;- df ~ lm(mpg ~ ., data=df)
plotlm &lt;- m ~ {
  par(mfrow=c(2,2))
  plot(m,ask=FALSE)
}

mtcars %|&gt;%
  runlm %|&gt;%
  plotlm
</code></pre>

<h3>
<a name="mixed-piping" class="anchor" href="#mixed-piping"><span class="octicon octicon-link"></span></a>Mixed piping</h3>

<p>All the pipe operators can be used together and each of them only works in their own way.</p>

<pre><code>mtcars %|&gt;%
  (df ~ lm(mpg ~ ., data=df)) %&gt;&gt;%
  summary %:&gt;%
  .$fstatistic
</code></pre>

<h3>
<a name="piping-with-dplyr-package" class="anchor" href="#piping-with-dplyr-package"><span class="octicon octicon-link"></span></a>Piping with <code>dplyr</code> package</h3>

<p><code>dplyr</code> package provides a group of functions that make data transformation much easier. <code>%.%</code> is a built-in chain operator that pipes the previous result to the first-argument in the next function call. <code>%&gt;&gt;%</code> is fully compatible with <code>dplyr</code> and can replace <code>%.%</code> with more consistency.</p>

<p>The following code demonstrates mixed piping with <code>dplyr</code> functions.</p>

<pre><code>library(dplyr)
library(hflights)
library(pipeR)
data(hflights)

hflights %&gt;&gt;%
  mutate(Speed=Distance/ActualElapsedTime) %&gt;&gt;%
  group_by(UniqueCarrier) %&gt;&gt;%
  summarize(n=length(Speed),speed.mean=mean(Speed,na.rm = T),
    speed.median=median(Speed,na.rm=T),
    speed.sd=sd(Speed,na.rm=T)) %&gt;&gt;%
  mutate(speed.ssd=speed.mean/speed.sd) %&gt;&gt;%
  arrange(desc(speed.ssd)) %:&gt;%
  barplot(.$speed.ssd, names.arg = .$UniqueCarrier,
    main=sprintf("Standardized mean of %d carriers", nrow(.)))
</code></pre>

<h2>
<a name="performance" class="anchor" href="#performance"><span class="octicon octicon-link"></span></a>Performance</h2>

<p>Each operators defined in this package specializes in its work and is made as simple as possible, Therefore the overhead is significantly lower than its peer implmentation in <code>magrittr</code> package. </p>

<p>In general, <code>pipeR</code> is more than 3 times faster than <code>magrittr</code> and can be more than 30 times faster when the pipeline gets longer or when the data gets bigger. The detailed performance tests can be seen in issues.</p>

<p>This package is only a simplified and specialized version of three types of pipeline operations. To assist your work, you can load both packages and use both set of functions and operators in practice.</p>

<h2>
<a name="help-overview" class="anchor" href="#help-overview"><span class="octicon octicon-link"></span></a>Help overview</h2>

<pre><code>help(package = pipeR)
</code></pre>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>This package is under <a href="http://opensource.org/licenses/MIT">MIT License</a>.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">pipeR maintained by <a href="https://github.com/renkun-ken">renkun-ken</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-47159422-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
