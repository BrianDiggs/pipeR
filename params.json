{"name":"pipeR","tagline":"High-performance pipeline operator and Pipe function","body":"\r\n\r\n# pipeR\r\n\r\n[![Build Status](https://travis-ci.org/renkun-ken/pipeR.png?branch=master)](https://travis-ci.org/renkun-ken/pipeR)\r\n\r\nHigh-performance pipeline operator and light-weight Pipe function based on a set of simple and intuitive rules, making command chaining definite, readable and fast.\r\n\r\n## What's new in 0.4?\r\n\r\n- **Major API Change**: `%>>%` operator now handles all pipeline mechanisms and other operators are deprecated.\r\n- Add `Pipe` object that supports object-based pipeline operation.\r\n\r\n[Release notes](https://github.com/renkun-ken/pipeR/releases)\r\n\r\n## Installation\r\n\r\nInstall from CRAN:\r\n\r\n```r\r\ninstall.packages(\"pipeR\")\r\n```\r\n\r\nInstall the development version from GitHub (`devtools` package is required):\r\n\r\n```r\r\ndevtools::install_github(\"pipeR\",\"renkun-ken\")\r\n```\r\n\r\n## Usage\r\n\r\n### `%>>%`\r\n\r\nIf `%>>%` is followed by\r\n\r\n* a function name or call like `f` or `f(...)`, pipe to first argument as `f(x)` or `f(x,...)`;\r\n* an expression enclosed within `{}` or `()`, pipe to `.` symbol;\r\n* a lambda expression like `(x -> expr)` or `(x ~ expr)`, pipe to lambda symbol, in this case, `x`.\r\n\r\nHere is a cheat-sheet:\r\n\r\n```r\r\nx %>>% f            # f(x)\r\nx %>>% f(...)       # f(x,...)\r\nx %>>% { f(.) }     # f(x)\r\nx %>>% ( f(.) )     # f(x)\r\nx %>>% (i -> f(i))  # f(x)\r\nx %>>% (i ~ f(i))   # f(x)\r\n```\r\n\r\n### `Pipe()`\r\n\r\n`Pipe()` creates a Pipe object that supports light-weight chaining without any external operator. Typically, start with `Pipe()` and end with `$value` or `[]` to extract the final value of the Pipe.\r\n\r\nWorking with [dplyr](https://github.com/hadley/dplyr):\r\n\r\n```r\r\nlibrary(dplyr)\r\nlibrary(pipeR)\r\nPipe(mtcars)$\r\n  filter(mpg >= mean(mpg))$\r\n  select(mpg, wt, qsec)$\r\n  fun(lm(mpg ~ ., data = .))$\r\n  summary()$\r\n  value\r\n```\r\n\r\nWorking with [ggvis](https://github.com/rstudio/ggvis):\r\n\r\n```r\r\nlibrary(ggvis)\r\nlibrary(pipeR)\r\nPipe(mtcars)$\r\n  ggvis(~ mpg, ~ wt)$\r\n  layer_points() []\r\n```\r\n\r\nHere is a cheat-sheet:\r\n\r\n```r\r\nPipe(x)$foo()$bar()         # build Pipe object for chaining\r\nPipe(x)$foo()$bar()$value   # extract the final value\r\nPipe(x)$foo()$bar() []      # extract the final value\r\nPipe(x)$fun(expr)           # pipe to \".\"\r\nPipe(x)$fun(x -> expr)      # pipe to \"x\"\r\nPipe(x)$fun(x ~ expr)       # pipe to \"x\"\r\n```\r\n\r\n## Examples\r\n\r\n### `%>>%`\r\n\r\nPipe as first-argument to a function:\r\n\r\n```r\r\nrnorm(100,mean=10) %>>%\r\n  log %>>%\r\n  diff %>>%\r\n  plot(col=\"red\")\r\n```\r\n\r\nPipe as `.` to an expression enclosed by `{}` or `()`:\r\n\r\n```r\r\nrnorm(100) %>>% {\r\n  x <- .[1:50]\r\n  y <- .[51:100]\r\n  lm(y ~ x)\r\n}\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(mpg ~ ., data = .))\r\n```\r\n\r\nPipe by lambda expression enclosed by `()`:\r\n\r\n```r\r\nmtcars %>>%\r\n  (df -> lm(mpg ~ ., data = df))\r\n\r\nmtcars %>>%\r\n  (df ~ lm(mpg ~ ., data = df))\r\n```\r\n\r\n### `Pipe()`\r\n\r\n`Pipe()` creates a Pipe object. \r\n\r\n- `$` chains functions by first-argument piping and always returns a Pipe object.\r\n- `fun()` evaluates an expression with `.` or by lambda expression.\r\n- `$value` or `[]` extracts the final value of the Pipe object.\r\n\r\nPipe as first-argument to a function:\r\n\r\n```r\r\nPipe(rnorm(100,mean=10))$\r\n  log()$\r\n  diff()$\r\n  plot(col=\"red\") []\r\n```\r\n\r\n```r\r\nPipe(1:10)$\r\n  fun(x -> x + rnorm(1))$\r\n  mean() []\r\n```\r\n\r\n## Performance\r\n\r\n[Benchmark tests](http://cran.r-project.org/web/packages/pipeR/vignettes/Performance.html) show that pipeR operator and Pipe object can achieve high performance especially when they are intensively called.\r\n\r\n- If you do not care about the performance of intensive calling and need heuristic distinction between different piping mechanisms, you may use `%>%` in [magrittr](https://github.com/smbache/magrittr) which also provides additional aliases of basic functions. \r\n- If you care about performance issues and are sure which type of piping you are using, pipeR can be a helpful choice.\r\n\r\n## Vignettes\r\n\r\nThe package also provides the following vignettes:\r\n\r\n- [Introduction](http://cran.r-project.org/web/packages/pipeR/vignettes/Introduction.html)\r\n- [Examples](http://cran.r-project.org/web/packages/pipeR/vignettes/Examples.html)\r\n- [Performance](http://cran.r-project.org/web/packages/pipeR/vignettes/Performance.html)\r\n\r\n\r\n## Help overview\r\n\r\n```r\r\nhelp(package = pipeR)\r\n```\r\n\r\n## License\r\n\r\nThis package is under [MIT License](http://opensource.org/licenses/MIT).\r\n","google":"UA-47159422-1","note":"Don't delete this file! It's used internally to help with page regeneration."}