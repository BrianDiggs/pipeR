<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to pipeR}
-->

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(comment="#",error=FALSE,tidy=FALSE)
```

# Introduction to pipeR

pipeR provides Pipe operator and function based on intuitive syntax.

## `%>>%`

### Pipe as first-argument to function

The pipe operator `%>>%` by default inserts the object on the left-hand side to the first argument of the **function** on the right-hand side. In other words, `x %>>% f(a=1)` will be transformed to and be evaluated as `f(.,a=1)` where `.` takes the value of `x`. It accepts both function call, e.g. `plot()` or `plot(col="red")`, and function name, e.g. `log` or `plot`.

```r
rnorm(100) %>>% 
  plot

rnorm(100) %>>% 
  plot()

rnorm(100) %>>% 
  plot(col="red")

rnorm(100) %>>% 
  sample(size=100,replace=FALSE) %>>% 
  hist
```

You can write commands in a chain (or pipeline) like

```r
rnorm(10000,mean=10,sd=1) %>>%
  sample(size=100,replace=FALSE) %>>%
  log %>>%
  diff %>>%
  plot(col="red",type="l")
```

In some cases, the next function needs first-argument piping and uses the piped object elsewhere too. Therefore, you can directly use `.` to represent the piped object within that call.

```r
rnorm(100) %>>%
  plot(col="red",main=sprintf("Number of points: %d",length(.)))
```

*Notice: function call in a namespace must end up with parentheses like `x %>>% base::mean()`.

### Pipe as `.` to expression

If a function name or call directly follows `%>>%`, it means first-argument piping. If the operator is follows by braces (`{}`), the inner expression will be evaluated with `.` representing the piped object.

```r
rnorm(100) %>>% 
  { plot(.) }

rnorm(100) %>>% 
  { plot(., col="red") }

rnorm(100) %>>% 
  { sample(., size=length(.)*0.5) }

mtcars %>>% {
  lm(mpg ~ cyl + disp, data=.) %>>% 
  summary
}

rnorm(100) %>>% {
  par(mfrow=c(1,2))
  hist(.,main="hist")
  plot(.,col="red",main=sprintf("%d",length(.)))
}
```

### Pipe by lambda expression

It can be confusing to see multiple `.` symbols in the same context. In some cases, they may represent different things in the same expression. Even though the expression mostly still works, it may not be a good idea to keep it in that way. Here is an example:

```r
mtcars %>>%
  { lm(mpg ~ ., data=.) } %>>%
  summary
```

The code above works correctly even though the two dots in the second line have different meanings. `.` in formula `mpg ~ .` represents all variables other than `mpg` in data frame `mtcars`; `.` in `data=.` represents `mtcars`. One way to reduce ambiguity is to use *lambda expression* that names the piped object on the left of `~` and specifies the expression to evaluate on the right.

`%>>%` will assume lambda expression follows when the next expression is enclosed by parentheses `()`. The lambda expression can be in the following forms:

- `expr` where `.` is by default used to represent the piped object.
- `x ~ expr` where `expr` will be evaluated with `x` representing the piped object.

The previous example can be rewritten with lambda expression like this:

```r
mtcars %>>%
  (df ~ lm(mpg ~ ., data=df)) %>>%
  summary
```
### Pipe for side effect

In some cases we may only need the side effect of an expression given the previous object. For example, we may want to print some message by `cat()`  in the console and continue piping with the input object rather than the output of `cat()` which is actually `NULL`.

The following syntax is interpreted as side-effect piping:

```r
x %>>% (~ expr)
x %>>% (~ p ~ expr)
```

The syntax starts with `(~` and is easy to distinguish from non-side-effect lines. The right-hand side is the expression to evaluate only for its side effect. `~ p ~ expr` will interpreted as to evaluated `expr` for side-effect with `p = x` and return `x`.

Both lines are evaluated by lambda expression but the output of the expression will be ignored and `x` are returned instead.

```r
rnorm(100) %>>%
  (~ cat("number of points:",length(.),"\n")) %>>%
  summary()
```

### Pipe for element extraction

If a name is enclosed within `()` following `%>>%`, like `x %>>% (name)`, the operator will extract the element named `name` from `x`.

```r
mtcars %>>%
  (mpg)

mtcars %>>%
  (lm(mpg ~ ., data = .)) %>>%
  summary() %>>%
  (coefficients)
```

The extraction works not only for list and data frame but also for vector, environment, and S4 object.

To evaluate an expression within the piped object if it is a list or environment, use `with()` can be helpful.

```r
list(a = 1, b = 2) %>>%
  with(a+2*b)
```

But this method does not work for vector and S4 object.

## Pipe function

`Pipe()` creates a Pipe object where built-in symbols are designed for building pipeline. 

- `$` chains functions by first-argument piping and always returns a Pipe object.
- `.(...)` evaluates an expression with `.` or by lambda expression, or for side effect, or simply extract a named element. The usage is exactly the same with `x %>>% (...)`.
- Subsetting, extracing, and assigning with Pipe on its inner value and Pipe object is preserved.
- `$value` or `[]` extracts the final value of the Pipe object.

### Usage

Pipe as first-argument to a function:

```r
Pipe(rnorm(100,mean=10))$
  log()$
  diff()$
  plot(col="red")
```

```r
Pipe(1:10)$
  .(x ~ x + rnorm(1))$
  mean() []
```

Pipe by lambda expression

```r
Pipe(mtcars)$
  .(lm(mpg ~ ., data = .))$
  summary() []
```

```r
Pipe(mtcars)$
  .(df ~ lm(mpg ~ ., data = df))$
  summary() []
```

Pipe for extracting element

```r
Pipe(mtcars)$
  .(mpg)$
  summary() []
```

Pipe for side effect

```r
Pipe(iris)$
  .(~ cat(length(.), "columns","\n"))$
  .(~ plot(.))$
  summary()
```

Subsetting Pipe object

```r
Pipe(mtcars)["mpg"]
```

Extracting from Pipe object

```r
Pipe(mtcars)[["mpg"]]
```

Assigning to Pipe object's element

```r
p <- Pipe(list(a=1,b=2))
p$a <- 0
p$b <- NULL
```

```r
p <- Pipe(list(a=1,b=2))
p["a"] <- 2
p[["b"]] <- 3
```


### Lazy evaluation

Pipe is lazily evaluated. Consider working with `ggvis`.

```r
p1 <- Pipe(mtcars)$
  ggvis(~ mpg, ~ wt)
```

The plot will not be evaluated until p1 is called or further Pipe is evaluated.

```r
p1$layer_points() []
p1$layer_bars() []
```

### Stored Pipe

Pipe can also be stored as function.

```r
f1 <- Pipe(rnorm(100))$plot
f1(col="red")
f1(col="green")
```

When the arguments are supplied, `plot()` will be evaluated. Although Pipe is lazy but its value is determined at first evaluation.
