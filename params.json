{"name":"pipeR","tagline":"Pipeline operators for R: Making command chaining flexible and straightforward","body":"# pipeR\r\n\r\nPipeline operators for R: Making command chaining flexible and straightforward\r\n\r\n## Motivation\r\n\r\nIn data-driven statistical computing and data analysis, applying a chain of commands step by step is a common situation. However, it is neigher straghtforawd nor flexible to write a group of deeply nested functions in that the last functions must be written first. For example, if we need to take the following steps:\r\n\r\n1. Generate 10000 random numbers from normal distribution with mean 10 and standard deviation 1\r\n2. Take a sample of 100 without replacement from these numbers\r\n3. Take a log of the sample\r\n4. Take a difference of the log numbers\r\n5. Plot these log differences as red line segments.\r\n\r\nHere is a translation from these steps to R commands:\r\n\r\n```\r\nplot(diff(log(sample(rnorm(10000,mean=10,sd=1),size=100,replace=FALSE))),col=\"red\",type=\"l\")\r\n```\r\n\r\nThe code is neither straightforward for reading nor flexible for modification.\r\n\r\nThis package provides two types of forward-piping mechanisms: first-argument piping and free piping. The two styles of piping are implemented by `%>%` and `%>>%`, respectively.\r\n\r\n### First-argument piping\r\n\r\nThe first-argument pipe operator `%>%` insert the previous expression before all other specified arguments if any. In other words, `x %>% f(a=1)` will be translated to `f(x,a=1)`.\r\n\r\nWith the first-argument pipe operator `%>%`, you may rewrite the first example like\r\n\r\n```\r\nrnorm(10000,mean=10,sd=1) %>%\r\n  sample(size=100,replace=FALSE) %>%\r\n  log %>%\r\n  diff %>%\r\n  plot(col=\"red\",type=\"l\")\r\n```\r\n\r\n### Free piping\r\n\r\nHowever, it may not always be the case where the last result serves as the first argument of the next function call. In this situation, you may use free pipe operator `%>>%` to allow `.` to represent the last result and let you decide where it should be piped to.\r\n\r\nWith the free pipe operator `%>>%`, you can do more with `.`:\r\n\r\n```\r\nrnorm(10000,mean=10,sd=1) %>>%\r\n  sample(.,size=length(.)/500,replace=FALSE) %>>%\r\n  log %>%\r\n  diff %>%\r\n  plot(.,col=\"red\",type=\"l\",main=sprintf(\"length: %d\",length(.)))\r\n```\r\n\r\nNo matter which one you use, or both in one chain, your code will become much clearer and maintainable.\r\n\r\n### Lambda piping\r\n\r\nIn some situations, it can be confusing to see multiple `.` symbols in the same expression as they represent different things. Even though the expression still works in most cases, it may not a good idea to keep it in that way. Here is an example:\r\n\r\n```\r\nmtcars %>>%\r\n  lm(mpg ~ ., data=.) %>%\r\n  summary\r\n```\r\n\r\nThe code above works correctly, although `.` in `mpg~.` represents all variables other than `mpg` and `.` in `data=.` represents `mtcars` dataset, as it is supposed. One way to reduce the ambiguity is to use *lambda expression*. Here we define a syntax like `x -> f(x)` where `->` means *map* rather than *assign* and `x` does not need to exist in the environment. Another symbol, `%|>%` is designed to handle piping with lambda expression, so we can rewrite the example above in this way:\r\n\r\n```\r\nmtcars %|>%\r\n  (df -> lm(mpg ~ ., data=df)) %>%\r\n  summary\r\n```\r\n\r\n## Installation\r\n\r\nThis package is not released to CRAN. You may install it through `devtools`.\r\n\r\n```\r\nif(!require(devtools)) install.packages(\"devtools\")\r\nrequire(devtools)\r\ninstall_github(\"pipeR\",\"renkun-ken\")\r\n```\r\n\r\n## Help overview\r\n\r\n```\r\nhelp(package = pipeR)\r\n```\r\n\r\n## Example of usage\r\n\r\n### First-argument piping with basic functions\r\n\r\n```\r\nrnorm(100) %>% plot\r\n\r\nrnorm(100) %>% plot(col=\"red\")\r\n\r\nrnorm(1000) %>% sample(size=100,replace=F) %>% hist\r\n```\r\n\r\n### Free piping with basic functions\r\n\r\n```\r\nrnorm(100) %>>% plot(.)\r\n\r\nrnorm(100) %>>% plot(.,col=\"red\")\r\n\r\nrnorm(1000) %>>% sample(.,length(.)*0.2,F)\r\n\r\nrnorm(1000) %>>% \r\n  sample(.,length(.)*0.2,F) %>>% \r\n  plot(.,main=sprintf(\"length: %d\",length(.)))\r\n\r\nrnorm(100) %>>% {\r\n  par(mfrow=c(1,2))\r\n  hist(.,main=\"hist\")\r\n  plot(.,col=\"red\",main=sprintf(\"%d\",length(.)))\r\n} \r\n```\r\n\r\n### Lambda piping with basic functions\r\n\r\n```\r\nrnorm(100) %|>% (x -> plot(x))\r\n\r\nrnorm(100) %|>% (x -> plot(x,col=\"red\"))\r\n\r\nrnorm(1000) %|>% (pop -> sample(pop,length(pop)*0.2,FALSE))\r\n\r\nrnorm(1000) %|>% \r\n  (pop -> sample(pop,length(pop)*0.2,FALSE)) %|>% \r\n  (s -> plot(s,main=sprintf(\"length: %d\",length(s))))\r\n```\r\n\r\n### Mixed piping\r\n\r\nAll the pipe operators can be used together and each of them plays a clear role.\r\n\r\n```\r\nmtcars %|>%\r\n  (df -> lm(mpg ~ ., data=df)) %>%\r\n  summary %>>%\r\n  .$r.squared\r\n```\r\n\r\n### Piping with `dplyr` package\r\n\r\n`dplyr` package provides a group of functions that make data transformation much easier. `%.%` is a built-in chain operator that pipes the previous result to the first-argument in the next function call. `%>%` is fully compatible with `dplyr` and can replace `%.%` with more consistency.\r\n\r\nThe following code demonstrates mixed piping with `dplyr` functions.\r\n\r\n```\r\nlibrary(dplyr)\r\nlibrary(hflights)\r\ndata(hflights)\r\n\r\nhflights %>%\r\n  mutate(Speed=Distance/ActualElapsedTime) %>%\r\n  group_by(UniqueCarrier) %>%\r\n  summarize(n=length(Speed),speed.mean=mean(Speed,na.rm = T),\r\n    speed.median=median(Speed,na.rm=T),\r\n    speed.sd=sd(Speed,na.rm=T)) %>%\r\n  mutate(speed.ssd=speed.mean/speed.sd) %>%\r\n  arrange(desc(speed.ssd)) %>>%\r\n  barplot(.$speed.ssd, names.arg = .$UniqueCarrier,\r\n    main=sprintf(\"Standardized mean of %d carriers\", nrow(.)))\r\n```\r\n","google":"UA-47159422-1","note":"Don't delete this file! It's used internally to help with page regeneration."}